# ToBe Pattern 1: 工程別Nabledge活用シーン

保守開発（既存資産活用）における工程別のNabledge活用例

```mermaid
flowchart TB
    subgraph req["要件定義"]
        req1["既存機能の影響範囲調査<br/>📊 既存設計書・コードから関連機能を自動抽出"]
        req2["技術的実現可能性検証<br/>🔍 既存パターンで実装可能か即座に回答"]
    end

    subgraph design["設計"]
        design1["既存パターンの踏襲<br/>📝 類似機能の設計書を参照して新規設計書を生成"]
        design2["整合性チェック<br/>✅ 既存の命名規則・設計パターンとの整合性を自動検証"]
    end

    subgraph pgut["PG・UT"]
        pgut1["既存コード理解<br/>📖 複雑なActionクラスの処理フローを図解"]
        pgut2["パターン踏襲実装<br/>⚙️ 既存Actionのパターンに合わせて新規コード生成"]
        pgut3["影響範囲分析<br/>🎯 共通部品の変更が他機能に与える影響を分析"]
        pgut4["リファクタリング提案<br/>💡 既存コードの改善余地を指摘"]
    end

    subgraph it["結合テスト"]
        it1["統合エラー原因特定<br/>🔍 複数機能連携エラーの原因を即座に特定"]
        it2["設計ミス検出<br/>⚠️ IF不整合、データ連携ミスを指摘"]
        it3["リグレッション影響分析<br/>🎯 既存機能への影響を事前分析"]
    end

    subgraph test["システムテスト"]
        test1["性能ボトルネック特定<br/>📊 処理遅延箇所を分析"]
        test2["障害調査支援<br/>🐛 ログ・スタックトレースから原因箇所を特定"]
    end

    req --> design
    design --> pgut
    pgut --> it
    it --> test
```

## ポイント

### 要件定義
- **既存資産の影響範囲が見える化される** - どの機能・ファイルに影響するか即座に把握
- **技術判断が早くなる** - 既存パターンで実現可能か、新規実装が必要かをAIが判断

### 設計
- **既存パターンを自動で踏襲** - 類似機能を参照して設計書ドラフト生成
- **設計の一貫性が保たれる** - 命名規則・パターンの逸脱を自動検出

### PG・UT
- **複雑な既存コードが理解しやすくなる** - 処理フローを図解、依存関係を可視化
- **既存パターンに沿った実装が楽になる** - 手本コードを参照して自動生成
- **影響範囲が見える** - 共通部品変更の影響を事前に把握、手戻り防止

### 結合テスト ⭐
- **PG・UTは通っても結合テストで動かない問題を解決** - 設計ミス（IF不整合、データ連携ミス）を事前検出
- **統合エラーの原因特定が早い** - 複数機能の連携エラー箇所を即座に特定
- **リグレッション影響が見える** - 既存機能への影響を事前分析、手戻り防止

### システムテスト
- **性能問題の原因が分かる** - ボトルネック箇所を分析、改善ポイントを提示
- **障害調査が早くなる** - ログから原因箇所を即座に特定
