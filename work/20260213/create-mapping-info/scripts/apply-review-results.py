#!/usr/bin/env python3
"""
Apply review results from agents to update mapping files.

This script reads the categorization review JSON files generated by agents
and updates the mapping-v6.json and mapping-v5.json files with corrected categories.
"""

import json
import sys
from pathlib import Path
from typing import Dict, List, Set

def load_json(file_path: Path) -> Dict:
    """Load JSON file."""
    with open(file_path, 'r', encoding='utf-8') as f:
        return json.load(f)

def save_json(file_path: Path, data: Dict):
    """Save JSON file with pretty formatting."""
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

def apply_v6_library_reviews(mapping: Dict) -> int:
    """Apply V6 library categorization reviews."""
    # V6 library categorization rules based on agent review
    batch_only_libraries = {
        'data_bind', 'data_format', 'format', 'data_converter',
        'format_definition', 'multi_format_example', 'file_path_management'
    }

    batch_and_rest_libraries = {
        'database_management', 'database', 'universal_dao', 'generator',
        'validation', 'bean_validation', 'nablarch_validation',
        'transaction', 'exclusive_control', 'message'
    }

    rest_only_libraries = {
        'jaxrs_access_log', 'role_check'
    }

    changes = 0
    for entry in mapping['mappings']:
        if not entry['in_scope']:
            continue

        if 'library' not in entry['categories']:
            continue

        file_path = entry['source_file']
        basename = Path(file_path).stem  # Get filename without extension

        # Check if this file needs batch-nablarch category
        matched_batch_only = [lib for lib in batch_only_libraries if lib in basename or f"/{lib}/" in file_path or f"/{lib}." in file_path]
        if matched_batch_only:
            if 'batch-nablarch' not in entry['categories']:
                entry['categories'].append('batch-nablarch')
                changes += 1
                print(f"  Added batch-nablarch to: {basename} (matched: {matched_batch_only})")

        # Check if this file needs both batch-nablarch and rest
        matched_both = [lib for lib in batch_and_rest_libraries if lib in basename or f"/{lib}/" in file_path or f"/{lib}." in file_path]
        if matched_both:
            if 'batch-nablarch' not in entry['categories']:
                entry['categories'].append('batch-nablarch')
                changes += 1
                print(f"  Added batch-nablarch to: {basename} (matched: {matched_both})")
            if 'rest' not in entry['categories']:
                entry['categories'].append('rest')
                changes += 1
                print(f"  Added rest to: {basename} (matched: {matched_both})")

        # Check if this file needs rest category
        matched_rest_only = [lib for lib in rest_only_libraries if lib in basename or f"/{lib}/" in file_path or f"/{lib}." in file_path]
        if matched_rest_only:
            if 'rest' not in entry['categories']:
                entry['categories'].append('rest')
                changes += 1
                print(f"  Added rest to: {basename} (matched: {matched_rest_only})")

    return changes

def apply_v5_library_reviews(mapping: Dict) -> int:
    """Apply V5 library categorization reviews (same as V6)."""
    return apply_v6_library_reviews(mapping)

def apply_v6_handler_reviews(mapping: Dict) -> int:
    """Apply V6 handler categorization reviews."""
    # Standalone handlers - add batch-nablarch
    standalone_handlers = [
        'retry_handler', 'duplicate_process_check_handler',
        'request_thread_loop_handler', 'process_stop_handler',
        'data_read_handler', 'multi_thread_execution_handler',
        'status_code_convert_handler', '/handlers/standalone/main'
    ]

    # Common handlers - add both batch-nablarch and rest
    common_both_handlers = [
        'database_connection_management_handler', 'global_error_handler',
        'thread_context_handler', 'thread_context_clear_handler',
        'transaction_management_handler'
    ]

    # Common handlers - add batch-nablarch only
    common_batch_handlers = [
        'file_record_writer_dispose_handler', 'request_path_java_package_mapping'
    ]

    # Common handlers - add rest only
    common_rest_handlers = [
        'permission_check_handler', 'request_handler_entry',
        'ServiceAvailabilityCheckHandler'
    ]

    changes = 0
    for entry in mapping['mappings']:
        if not entry['in_scope']:
            continue

        if 'handler' not in entry['categories']:
            continue

        file_path = entry['source_file']

        # Standalone handlers
        if any(handler in file_path for handler in standalone_handlers):
            if 'batch-nablarch' not in entry['categories']:
                entry['categories'].append('batch-nablarch')
                changes += 1

        # Common handlers for both patterns
        if any(handler in file_path for handler in common_both_handlers):
            if 'batch-nablarch' not in entry['categories']:
                entry['categories'].append('batch-nablarch')
                changes += 1
            if 'rest' not in entry['categories']:
                entry['categories'].append('rest')
                changes += 1

        # Common handlers for batch only
        if any(handler in file_path for handler in common_batch_handlers):
            if 'batch-nablarch' not in entry['categories']:
                entry['categories'].append('batch-nablarch')
                changes += 1

        # Common handlers for REST only
        if any(handler in file_path for handler in common_rest_handlers):
            if 'rest' not in entry['categories']:
                entry['categories'].append('rest')
                changes += 1

    return changes

def apply_v5_handler_reviews(mapping: Dict) -> int:
    """Apply V5 handler categorization reviews (similar to V6)."""
    # Standalone handlers - add batch-nablarch
    standalone_handlers = [
        'retry_handler', 'duplicate_process_check_handler',
        'process_stop_handler', 'data_read_handler',
        'multi_thread_execution_handler', 'status_code_convert_handler',
        '/handlers/standalone/main'
    ]

    # Common handlers - add both batch-nablarch and rest
    common_both_handlers = [
        'database_connection_management_handler', 'global_error_handler',
        'thread_context_handler', 'thread_context_clear_handler',
        'transaction_management_handler'
    ]

    # Common handlers - add batch-nablarch only
    common_batch_handlers = [
        'file_record_writer_dispose_handler'
    ]

    # Common handlers - add rest only
    common_rest_handlers = [
        'permission_check_handler', 'ServiceAvailabilityCheckHandler'
    ]

    changes = 0
    for entry in mapping['mappings']:
        if not entry['in_scope']:
            continue

        if 'handler' not in entry['categories']:
            continue

        file_path = entry['source_file']

        # Standalone handlers
        if any(handler in file_path for handler in standalone_handlers):
            if 'batch-nablarch' not in entry['categories']:
                entry['categories'].append('batch-nablarch')
                changes += 1

        # Common handlers for both patterns
        if any(handler in file_path for handler in common_both_handlers):
            if 'batch-nablarch' not in entry['categories']:
                entry['categories'].append('batch-nablarch')
                changes += 1
            if 'rest' not in entry['categories']:
                entry['categories'].append('rest')
                changes += 1

        # Common handlers for batch only
        if any(handler in file_path for handler in common_batch_handlers):
            if 'batch-nablarch' not in entry['categories']:
                entry['categories'].append('batch-nablarch')
                changes += 1

        # Common handlers for REST only
        if any(handler in file_path for handler in common_rest_handlers):
            if 'rest' not in entry['categories']:
                entry['categories'].append('rest')
                changes += 1

    return changes

def apply_v6_devguide_reviews(mapping: Dict) -> int:
    """Apply V6 dev guide categorization reviews."""
    batch_pattern_files = [
        'Nablarchバッチ処理パターン.md',
        'Nablarch_batch_processing_pattern.md'
    ]

    changes = 0
    for entry in mapping['mappings']:
        if not entry['in_scope']:
            continue

        file_path = entry['source_file']

        # Add batch-nablarch to batch processing pattern files
        if any(pattern_file in file_path for pattern_file in batch_pattern_files):
            if 'batch-nablarch' not in entry['categories']:
                entry['categories'].append('batch-nablarch')
                changes += 1

    return changes

def main():
    """Main entry point."""
    script_dir = Path(__file__).parent
    work_dir = script_dir.parent

    # Process V6
    print("Applying V6 categorization reviews...")
    mapping_v6_file = work_dir / 'mapping-v6.json'
    mapping_v6 = load_json(mapping_v6_file)

    v6_changes = 0
    v6_changes += apply_v6_library_reviews(mapping_v6)
    v6_changes += apply_v6_handler_reviews(mapping_v6)
    v6_changes += apply_v6_devguide_reviews(mapping_v6)

    save_json(mapping_v6_file, mapping_v6)
    print(f"Updated {mapping_v6_file}")
    print(f"  Applied {v6_changes} category additions")

    # Process V5
    print("\nApplying V5 categorization reviews...")
    mapping_v5_file = work_dir / 'mapping-v5.json'
    mapping_v5 = load_json(mapping_v5_file)

    v5_changes = 0
    v5_changes += apply_v5_library_reviews(mapping_v5)
    v5_changes += apply_v5_handler_reviews(mapping_v5)

    save_json(mapping_v5_file, mapping_v5)
    print(f"Updated {mapping_v5_file}")
    print(f"  Applied {v5_changes} category additions")

    print("\nReview results applied successfully!")
    print(f"Total changes: {v6_changes + v5_changes}")

if __name__ == '__main__':
    main()
